[{"title":"代码整洁之道","url":"http://cozelight.com/2018/09/18/代码整洁之道/","content":"<p><img src=\"http://o8anxf7e1.bkt.clouddn.com/wtfm.jpg\" alt=\"wtfm\"></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>抛砖引玉，更详细内容还是在《<a href=\"https://www.amazon.cn/dp/B0031M9GHC/ref=sr_1_1?ie=UTF8&amp;qid=1537711434&amp;sr=8-1&amp;keywords=%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93\" target=\"_blank\" rel=\"noopener\">代码整洁之道</a>》一书中，本文摘自其中部分内容。<strong>注意，只是部分内容！</strong>如书中所言，学习整洁代码很难，它可不至于要求你掌握原则和模式。你得在这上面花功夫。你须自行实践，且体验自己的失败。你须观察他人的实践与失败。阅读代码——大量代码。而且你要去琢磨某段代码好在什么地方，坏在什么地方。最后强烈建议大家都去认真阅读《<a href=\"https://www.amazon.cn/dp/B0031M9GHC/ref=sr_1_1?ie=UTF8&amp;qid=1537711434&amp;sr=8-1&amp;keywords=%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93\" target=\"_blank\" rel=\"noopener\">代码整洁之道</a>》</p>\n<h3 id=\"一、有意义的命名\"><a href=\"#一、有意义的命名\" class=\"headerlink\" title=\"一、有意义的命名\"></a>一、有意义的命名</h3><p><img src=\"http://o8anxf7e1.bkt.clouddn.com/WX20180919-113215@2x.png\" alt=\"WX20180919-113215@2x\"></p>\n<p>推荐网站：<a href=\"http://unbug.github.io/codelf/\" target=\"_blank\" rel=\"noopener\">CODEIF</a></p>\n<h4 id=\"1-名副其实\"><a href=\"#1-名副其实\" class=\"headerlink\" title=\"1. 名副其实\"></a>1. 名副其实</h4><p>如果名称需要注释来补充，那就不算是名副其实</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;<span class=\"keyword\">int</span> []&gt; getThem() &#123;</span><br><span class=\"line\">    List&lt;<span class=\"keyword\">int</span> []&gt; list1 = <span class=\"keyword\">new</span> ArrayList&lt;<span class=\"keyword\">int</span> []&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>[] x : theList)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x[<span class=\"number\">0</span>] == <span class=\"number\">4</span>) </span><br><span class=\"line\">            list1.add(x);</span><br><span class=\"line\">   \t<span class=\"keyword\">return</span> list1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>问题不在于代码的简洁度，而是在于代码的<strong>模糊度</strong>：即上下文在代码中未被明确体现的程度。上例代码要求我们了解类似以下问题的答案：</p>\n<ul>\n<li><code>theList</code> 中是什么类型的东西？</li>\n<li><code>theList</code> 零下标条目的意义是什么？</li>\n<li>值 4 的意义是什么？</li>\n<li>我怎么使用返回的列表？</li>\n</ul>\n<p>问题的答案没体现在代码段中，可那就是它们该在的地方。比方说，我们再开发一种扫雷游戏，我们发现，盘面是名为 <code>theList</code> 的单元格列表，那就将其名称改为 <code>gameBoard</code></p>\n<p>盘面上每个单元格都用一个简单数组表示。我们还发现，零下标条目是一种状态值，而该种状态值为 4 表示“已标记”。只要改为有意义的名称，代码就会得到相当程度的改进：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;<span class=\"keyword\">int</span> []&gt; getFlaggedCells() &#123;</span><br><span class=\"line\">    List&lt;<span class=\"keyword\">int</span> []&gt; flaggedCells = <span class=\"keyword\">new</span> ArrayList&lt;<span class=\"keyword\">int</span> []&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>[] cell : gameBoard)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cell[STATUS_VALUE] == FLAGGED) </span><br><span class=\"line\">            flaggedCells.add(cell);</span><br><span class=\"line\">   \t<span class=\"keyword\">return</span> flaggedCells;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还可以更进一步，不用 int 数组表示单元格，而是另写一个类。该类包括一个名副其实的函数(成为 <code>isFlagged</code> )，从而掩盖住那个魔法数字：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Cell&gt; <span class=\"title\">getFlaggedCells</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Cell&gt; flaggedCells = <span class=\"keyword\">new</span> ArrayList&lt;Cell&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Cell cell : gameBoard)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cell.isFlagged()) </span><br><span class=\"line\">            flaggedCells.add(cell);</span><br><span class=\"line\">   \t<span class=\"keyword\">return</span> flaggedCells;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-使用可搜索的名称\"><a href=\"#2-使用可搜索的名称\" class=\"headerlink\" title=\"2. 使用可搜索的名称\"></a>2. 使用可搜索的名称</h4><p>单字母名称和数字常量有个问题，就是很难在一大篇文字中找出来。</p>\n<p>找 <code>MAX_CLASSES_PER_STUDENT</code> 很容易，但想找数字 7 就麻烦了，它可能是某些文件名或其它常量定义的一部分。如果该常量是个长数字，又被人错改过，就会逃过搜索，从而造成错误。</p>\n<p>单字母名称仅用于短方法中的本地变量。名称长短应与其作用域大小相对应。若变量或常量可能在代码中多处使用，则应赋予其便于搜索的名称。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;<span class=\"number\">34</span>; j++) &#123;</span><br><span class=\"line\">    s += (t[j]*<span class=\"number\">4</span>)/<span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> realDaysPerIdealDay = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> WORK_DAYS_PER_WEEK = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j &lt; NUMBER_OF_TASKS; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> realTaskDays = taskEstimate[j] * realDaysPerIdealDay;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> realTaskWeeks = (realTaskDays / WORK_DAYS_PER_WEEK);</span><br><span class=\"line\">    sum += realTaskWeeks;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码中的<code>sum</code>并非特别有用的名称，不过它至少搜索得到。采用能表达意图的名称，貌似拉长了函数代码，但要想想看，<code>WORK_DAYS_PER_WEEK</code> 要比数字 5 好找得多。</p>\n<h3 id=\"二、函数\"><a href=\"#二、函数\" class=\"headerlink\" title=\"二、函数\"></a>二、函数</h3><ol>\n<li><p>短小</p>\n<p>函数的第一规则是要短小，第二条规则是还要更短小。</p>\n</li>\n<li><p>只做一件事</p>\n<p>函数应该做一件事，做好这件事，只做这一件事。</p>\n</li>\n<li><p>函数参数</p>\n<p>最理想的参数数量是 0，其次是 1，再次是 2</p>\n<p>参数不易对付，它们带有太多概念性。从测试的角度看，要编写能确保参数的各种组合运行正常的测试用例，是多么困难的事。</p>\n<p>如果函数看来需要三个或三个以上参数，就说明其中一些参数应该封装为类了。</p>\n</li>\n<li><p>无副作用</p>\n<p>副作用是一种谎言。函数承诺只做一件事，但还是会做其他被藏起来的事。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserValidator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Cryptographer cryptographer;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">checkPassword</span><span class=\"params\">(String userName, String password)</span> </span>&#123;</span><br><span class=\"line\">        User user = UserGateway.findByName(userName);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (user != User.NULL) &#123;</span><br><span class=\"line\">            String codedPhrase = user.getPhraseEncodedByPassword();</span><br><span class=\"line\">            String phrase = cryptographer.decrypt(codedPhrase, password);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"string\">\"Valid Password\"</span>.equals(phrase)) &#123;</span><br><span class=\"line\">                Session.initialize();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然了，副作用就在于对<code>Session.initialize()</code>的调用。<code>checkPassword</code>函数，顾名思义，就是用来检查密码的。该名称并未暗示它会初始化该次会话。所以，当某个误信了函数名的调用者想要检查用户有效性时，就得冒抹除现有会话数据的风险。可以重命名函数为<code>checkPasswordAndInitializeSession</code>，虽然那还是违反了“只做一件事”的规则。</p>\n</li>\n<li><p>分隔指令与询问</p>\n<p>函数要么做什么事，要么回答什么事，但二者不可得兼。函数应该修改某对象的状态，或是返回该对象的有关信息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">set</span><span class=\"params\">(String attribute, String value)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (set(<span class=\"string\">\"username\"</span>, <span class=\"string\">\"Lucy\"</span>)) ...</span><br></pre></td></tr></table></figure>\n<p>它是在问<code>username</code>属性值是否之前已设置为<code>Lucy</code>吗？或者它是在问<code>username</code>属性值是否成功设置为<code>Lucy</code>呢？要解决这个问题，可以将<code>set</code>函数重命名为<code>setAndCheckIfExists</code>，但这对提高if语句的可读性帮助不大。真正的解决方案是把指令与询问分隔开来，防止混淆的发生：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (attributeExists(<span class=\"string\">\"username\"</span>)) &#123;</span><br><span class=\"line\">    setAttribute(<span class=\"string\">\"username\"</span>, <span class=\"string\">\"Lucy\"</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>别重复自己</p>\n<p>重复可能是软件中一切邪恶的根源。许多原则与实践规则都是为控制与消除重复而创建。面向对象编程是如何将代码集中到基类，从而避免冗余。面向切面编程、面向组件编程多少都是消除重复的一种策略。</p>\n</li>\n</ol>\n<p><strong>总结：</strong></p>\n<blockquote>\n<p>写函数时，一开始都冗长而复杂。有太多缩进和嵌套循环。有过长的参数列表。名称是随意取的，也会有重复代码。不过一定会配上一套单元测试，覆盖每行丑陋的代码。</p>\n<p>然后开始打磨这些代码，分解函数，修改名称，消除重复。缩短和重新安置方法。有时还会拆散类。同时保证测试通过。</p>\n<p>并不是从一开始就按规则写函数，没有人可以做到。</p>\n</blockquote>\n<h3 id=\"三、注释\"><a href=\"#三、注释\" class=\"headerlink\" title=\"三、注释\"></a>三、注释</h3><p>什么也比不上放置良好的注释来得有用。什么也不会比乱七八糟的注释更有本事搞乱一个模块。什么也不会比陈旧、提供错误信息的注释更有破坏性。若编程语言足够有表达力，或者我们长于用这些语言来表达意图，就不那么需要注释——也许根本不需要。</p>\n<p>为什么要极力贬低注释？因为注释会撒谎。也不是说总是如此或有意如此，但出现得实在太频繁。注释存在时间越长，就离其所描述的代码越远，越来越变得全然错误。原因很简单，程序员不能坚持维护注释。</p>\n<p>程序员应当负责将注释保持在可维护、有关联、精确的高度。我同意这种说法。但我更主张把力气用在写清楚代码上，直接保证无须编写注释。</p>\n<p>不准确的注释要比没注释坏得多。它们满口胡言。它们预期的东西永不能实现。它们设定了无需也不应再遵循的旧规则。</p>\n<p>真实只在一处地方有：代码。只有代码能忠实地告诉你它做的事。那是唯一真正准确的信息来源。所以，尽管有时也需要注释，我们也该多花心思尽量减少注释量。</p>\n<h3 id=\"四、单元测试\"><a href=\"#四、单元测试\" class=\"headerlink\" title=\"四、单元测试\"></a>四、单元测试</h3><ol>\n<li><p>TDD三定律</p>\n<p>谁都知道TDD要求我们在编写生产代码前先编写单元测试。但这条规则只是冰山之巅。看看下列三定律：</p>\n<ul>\n<li>定律一　在编写不能通过的单元测试前，不可编写生产代码。</li>\n<li>定律二　只可编写刚好无法通过的单元测试，不能编译也算不通过。</li>\n<li>定律三　只可编写刚好足以通过当前失败测试的生产代码。</li>\n</ul>\n<p>这三条定律将你限制在大概30秒一个的循环中。测试与生产代码一起编写，测试只比生产代码早写几秒钟。这样写程序，我们每天就会编写数十个测试，每个月编写数百个测试，每年编写数千个测试。这样写程序，测试将覆盖所有生产代码。测试代码量足以匹敌生产代码量，导致令人生畏的管理问题。</p>\n</li>\n<li><p>保持测试整洁</p>\n<p>整洁的测试有什么要素？有三个要素：可读性，可读性和可读性。在单元测试中，可读性甚至比在生产代码中还重要。测试如何才能做到可读？和其他代码中一样：明确，简洁，还有足够的表达力。在测试中，你要以尽可能少的文字表达大量内容。</p>\n</li>\n<li><p>F.I.R.S.T</p>\n<ul>\n<li>快速（Fast）测试应该够快。测试应该能快速运行。测试运行缓慢，你就不会想要频繁地运行它。如果你不频繁运行测试，就不能尽早发现问题，也无法轻易修正，从而也不能轻而易举地清理代码。最终，代码就会腐坏。</li>\n<li>独立（Independent）测试应该相互独立。某个测试不应为下一个测试设定条件。你应该可以单独运行每个测试，及以任何顺序运行测试。当测试互相依赖时，头一个没通过就会导致一连串的测试失败，使问题诊断变得困难，隐藏了下级错误。</li>\n<li>可重复（Repeatable）测试应当可在任何环境中重复通过。你应该能够在生产环境、测试环境中运行测试，也能够在无网络的列车上用笔记本电脑运行测试。如果测试不能在任意环境中重复，你就总会有个解释其失败的借口。当环境条件不具备时，你也会无法运行测试。</li>\n<li>自足验证（Self-Validating）测试应该有布尔值输出。无论是通过或失败，你不应该查看日志文件来确认测试是否通过。你不应该手工对比两个不同文本文件来确认测试是否通过。如果测试不能自足验证，对失败的判断就会变得依赖主观，而运行测试也需要更长的手工操作时间。</li>\n<li>及时（Timely）测试应及时编写。单元测试应该恰好在使其通过的生产代码之前编写。如果在编写生产代码之后编写测试，你会发现生产代码难以测试。你可能会认为某些生产代码本身难以测试。你可能不会去设计可测试的代码。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"五、类\"><a href=\"#五、类\" class=\"headerlink\" title=\"五、类\"></a>五、类</h3><ol>\n<li><p>单一权责原则（SRP）</p>\n<p>类或模块应有且只有一条加以修改的理由。</p>\n<p>让软件能工作和让软件保持整洁，是两种截然不同的工作。我们中的大多数人脑力有限，只能更多地精力放在让代码能工作上，而不是放在保持代码有组织和整洁上。分而治之，其在编程行为中的重要程度等同于在程序中的重要程度。</p>\n<p>许多开发者害怕数量巨大的短小单一目的的类会导致难以一目了然抓住全局。然而，有大量短小类的系统并不比有少量庞大类的系统拥有更多移动部件，其数量大致相等。</p>\n<p>问题是：你是想把工作归置到有许多抽屉、每个抽屉中装有定义和标记良好的组件的工具箱中呢，还是想要少数几个能随便把所有东西扔进去的抽屉？</p>\n</li>\n<li><p>内聚</p>\n<p>类应该只有少量实体变量。类中的每个方法都应该操作一个或多个这种变量。通常而言，方法操作的变量越多，就越黏聚到类上。如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。</p>\n<p>一般来说，创建这种极大化内聚类是既不可取也不可能的；另一方面，我们希望内聚性保持在较高位置。内聚性高，意味着类中的方法和变量互相依赖、互相结合成一个逻辑整体。</p>\n<p>保持内聚性就会得到许多短小的类</p>\n</li>\n</ol>\n<p>Talk is cheap, show me the code</p>\n<p>你可能注意到的第一件事就是程序比原来长了许多，从1页多增加到了将近3页。这有几个原因。其一，重构后的程序采用了更长、更有描述性的变量名。其二，重构后的程序将函数和类声明当作是给代码添加注释的一种手段。其三，我们采用了空格和格式技巧让程序更可读。</p>\n<p>留意程序是如何被拆分为3个主要权责的。<code>PrimePrinter</code>类中只有主程序。主程序的权责是处理执行环境。如果调用方式改变，它也会随之改变</p>\n<p><code>RowColumnPagePrinter</code>类懂得如何将数字列表格式化到有着固定行、列数的页面上。若输出格式需要改动，则该类也会被影响到。</p>\n<p><code>PrimeGenerator</code>类懂得如何生成素数列表。注意，这并不意味着要实体化为对象。该类就是个有用的作用域，在其中声明并隐藏变量。如果计算素数的算法发生改动，则该类也会改动。</p>\n<h3 id=\"六、迭代\"><a href=\"#六、迭代\" class=\"headerlink\" title=\"六、迭代\"></a>六、迭代</h3><p>“一开始就做对系统”纯属神话，反之，我们应该只去实现今天的用户故事，然后重构，明天再扩展系统、实现新的用户故事。这就是迭代和增量敏捷的精髓所在。测试驱动开发、重构以及它们打造出的整洁代码，在代码层面保证了这个过程的实现。</p>\n<p><strong>简单设计</strong>的四条规则，对于创建具有良好设计的软件有着莫大的帮助。</p>\n<ul>\n<li>运行所有测试；</li>\n<li>不可重复；</li>\n<li>表达了程序员的意图；</li>\n<li>尽可能减少类和方法的数量；</li>\n</ul>\n<p><strong>以上规则按其重要程度排列</strong></p>\n<p>全面测试并持续通过所有测试的系统，就是可测试的系统。看似浅显，但却重要。</p>\n<p>只要系统可测试，就会导向保持类短小且目的单一的设计方案。测试编写得越多，就越能持续走向编写较易测试的代码。所以，确保系统完全可测试能帮助我们创建更好的设计。</p>\n<p>紧耦合的代码难以编写测试。同样，编写测试越多，就越会使用依赖注入、接口和抽象等工具尽可能减少耦合。如此一来，设计就有长足进步。</p>\n<p>遵循有关编写测试并持续运行测试的简单、明确的规则，系统就会更贴近低耦合度、高内聚度的目标。编写测试以引致更好的设计。</p>\n<p>有了测试，就能保持代码和类的整洁，方法就是递增式地重构代码。添加了几行代码后，就要暂停，琢磨一下变化了的设计。设计退步了吗？如果是，就要清理它，并且运行测试，保证没有破坏任何东西。测试消除了对清理代码就会破坏代码的恐惧。</p>\n<p>在重构过程中，可以应用有关优秀软件设计的一切知识。提升内聚性，降低耦合度，切分关注面，模块化系统性关注面，缩小函数和类的尺寸，选用更好的名称，如此等等。这也是应用简单设计后三条规则的地方：消除重复，保证表达力，尽可能减少类和方法的数量。</p>\n<p>为了保持类和函数短小，我们可能会造出太多的细小类和方法。所以这条规则也主张函数和类的数量要少。</p>\n<p>类和方法的数量太多，有时是由毫无意义的教条主义导致的。例如，某个编码标准就坚称应当为每个类创建接口。也有开发者认为，字段和行为必须切分到数据类和行为类中。应该抵制这类教条，采用更实用的手段。</p>\n<p>我们的目标是在保持函数和类短小的同时，保持整个系统短小精悍。不过要记住，这在关于简单设计的四条规则里面是优先级最低的一条。所以，尽管使类和函数的数量尽量少是很重要的，但更重要的却是测试、消除重复和表达力。</p>\n","categories":[],"tags":[]},{"title":"IM 消息 UI 框架设计系列 篇一 消息整体框架设计","url":"http://cozelight.com/2018/03/13/IM 消息 UI 框架设计系列 篇一 消息整体框架设计/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>如果从零开始设计消息界面，应该考虑哪些问题。<br>架构的选型，消息页面承载了各种各样的业务，不应该所有业务都集中在 VC，随着业务的增长，VC 只会越来越臃肿，合适的架构，不仅便于拓展，也有利于消息页面的长足发展。</p>\n<p>消息页面业务列表：</p>\n<ul>\n<li>消息接收，发送，更新</li>\n<li>消息的上下加载</li>\n<li>不同消息 cell 展示</li>\n<li>cell 长按 menu 事件</li>\n<li>cell 内点击事件</li>\n<li>输入框事件</li>\n<li>不同消息页的展示</li>\n</ul>\n<p>由于篇幅内容涵盖较广，故本系列文章分为四篇(算是给自己挖个坑)：</p>\n<ol>\n<li><a href=\"http://www.cozelight.com/2018/03/18/im-消息-ui-框架设计系列-篇一-消息整体框架设计/\" target=\"_blank\" rel=\"noopener\">IM 消息 UI 框架设计系列 篇一 消息整体框架</a></li>\n<li>IM 消息 UI 框架设计系列 篇二 消息模型和视图</li>\n<li>IM 消息 UI 框架设计系列 篇三 消息输入框</li>\n<li>IM 消息 UI 框架设计系列 篇四 多媒体相关</li>\n</ol>\n<h2 id=\"消息界面框架\"><a href=\"#消息界面框架\" class=\"headerlink\" title=\"消息界面框架\"></a>消息界面框架</h2><p>消息界面 <code>MessageViewController</code> 继承 <code>UIViewController</code>，由 <code>UITableView(界面)</code>，<code>MessageConfig (消息配置)</code>，<code>MessageInteractor (逻辑控制器)</code> 作为基本构成。</p>\n<h3 id=\"消息配置类\"><a href=\"#消息配置类\" class=\"headerlink\" title=\"消息配置类\"></a>消息配置类</h3><p>APP 内会存在不同消息界面展示需求，如单聊，群聊，公众号，历史消息浏览等，框架抽象出一些常用的配置接口以便于业务方修改界面。配置类不是必须实现的，如果不实现，则使用默认配置。</p>\n<p>配置类具体注入步骤为:</p>\n<ul>\n<li><p>继承消息类 <code>MessageViewController</code> 。</p>\n</li>\n<li><p>创建配置类，实现协议 <code>MessageConfig</code>。</p>\n</li>\n<li><p>在继承的消息类中，重写父类接口 <code>- (id&lt;MessageConfig&gt;)messageConfig</code> 方法，返回创建的配置类。</p>\n</li>\n</ul>\n<h3 id=\"逻辑实现类\"><a href=\"#逻辑实现类\" class=\"headerlink\" title=\"逻辑实现类\"></a>逻辑实现类</h3><p>由于消息界面比较复杂，框架抽象出了逻辑实现类接口 <code>MessageInteractor</code></p>\n<p><code>MessageInteractor</code> 由 数据逻辑 <code>MessageDataSource</code> 和 排版逻辑 <code>MessageLayout</code> 两部分接口组成。</p>\n<p>数据逻辑 <code>MessageDataSource</code> 主要用于消息的数据的增删改查，作为界面的数据源，并缓存一些计算的中间数据，避免重复运算，提高性能。</p>\n<p>排版逻辑 <code>MessageLayout</code> 主要用于消息的排版操作， <code>MessageLayout</code> 不关心具体数据，只根据上层控制，对界面排版做出调整。</p>\n<h2 id=\"消息展示逻辑\"><a href=\"#消息展示逻辑\" class=\"headerlink\" title=\"消息展示逻辑\"></a>消息展示逻辑</h2><h3 id=\"消息普通展示\"><a href=\"#消息普通展示\" class=\"headerlink\" title=\"消息普通展示\"></a>消息普通展示</h3><ul>\n<li>消息通过 <code>srvMsgId</code> 和 <code>clientOrder</code> 两者共同排序。<code>srvMsgId</code>，为服务器生成的消息有序 Id。<code>clientOrder</code> 为本地客户端生成的有序数列。消息排序时，先根据 <code>srvMsgId</code> 进行排序，如果srvMsgId 一致，则在比较 <code>clientOrder</code>。正常情况下，发送成功的消息，即拥有唯一 <code>srvMsgId</code>。但客户端新建一条待发送的消息时，该消息的 <code>srvMsgId</code>，取至本地消息最大的 <code>srvMsgId</code>，同时 <code>clientOrder</code> 在最大消息的 <code>clientOrder</code> 上加一。这样子保证了本地消息排序的有序。等到新消息发送成功，服务器返回后，更新该 <code>srvMsgId</code> 为服务器的最新 <code>srvMsgId</code>，同时 <code>clientOrder</code> 置为0。<blockquote>\n<p>消息发送成功后，返回 <code>srvMsgId</code> 可能导致排序变化，出于性能考量，不对已展示消息重新排序，等用户下次再进入消息界面，即会展示正确的消息排序。</p>\n</blockquote>\n</li>\n<li>上拉拉取数据逻辑，异步加载一屏本地数据，如果本地数据不足一屏，则再异步拉取服务器数据。凑满一屏数据后，返回界面展示。当服务器返回无更多数据后，上拉拉取UI控件隐藏</li>\n<li><p>一直加载老数据，使得数据源消息数大于设定的最大值时，则清楚数据源内排序靠后的老数据，同时向下加载更多 UI 控件变更为显示</p>\n<blockquote>\n<p>上拉拉取时，菊花开始转，<code>tableView</code> 处于滑动状态，<code>offset</code> 一直在变。应该等 <code>tableVew</code> 停止滑动后，再开始进行 <code>tableView</code> 的 <code>reloadData</code> 操作，重设 offset。所以调用 <code>performSelectorOnMainThread:withObject:waitUntilDone:modes:</code> 执行 <code>reloadData</code> 操作，该方法能在 <code>tableView</code> 停止滑动，即 runloop 空闲后执行操作。</p>\n</blockquote>\n</li>\n<li><p>下拉加载数据逻辑，仅当向下加载更多UI控件显示时，触发。逻辑同上拉拉取逻辑一致。当服务器返回无更多数据后，向下加载更多UI控件隐藏。</p>\n</li>\n<li>点击输入框时，界面直接跳转至最新数据展示。以向下加载更多UI控件是否隐藏作为标志位，如果隐藏，说明当前数据即为最新数据，界面直接跳转至末尾。如果显示，则当前数据不是最新数据，则清空界面数据，异步拉取最新一屏本地数据展示，同时异步拉取服务器最新数据，待服务器数据返回后，再和本地数据合并，展示在界面。</li>\n<li>接收新消息时，后台线程计算Layout，计算完毕后，放入 <code>pendingMessage</code> 数组，在合适的时机，如 <code>tableView</code> 无滑动时，切主线程，一个一个的加入数据源，更新 <code>tableView</code>。如果数据源消息大于设定最大值，则清理数据源内排序靠前的老数据</li>\n</ul>\n<h3 id=\"正常进入消息界面\"><a href=\"#正常进入消息界面\" class=\"headerlink\" title=\"正常进入消息界面\"></a>正常进入消息界面</h3><ul>\n<li>同步加载一屏本地数据，同时异步拉取服务器最新数据</li>\n<li>服务器最新数据返回，如果与本地一致，不做处理。如果数据量大于一屏，清楚之前加载数据，替换数据为最新一屏数据。如果数据量小于一屏，则在展示的本地数据后，直接添加最新数据</li>\n<li>向下加载更多UI控件隐藏</li>\n</ul>\n<h3 id=\"指定跳转某一条消息\"><a href=\"#指定跳转某一条消息\" class=\"headerlink\" title=\"指定跳转某一条消息\"></a>指定跳转某一条消息</h3><ul>\n<li>以该条消息为基准，异步上下加载一屏本地数据，如果本地数据不足一屏，则再异步拉取服务器数据。凑满一屏数据后，返回界面展示</li>\n<li>向下加载更多UI控件不隐藏</li>\n</ul>\n","categories":[],"tags":[]},{"title":"iOS端Hybrid框架搭建","url":"http://cozelight.com/2018/03/08/iOS端Hybrid框架搭建/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Hybrid 作为一种混合开发模式，依赖 Native 端的 Web 容器（UIWebView / WKWebView），上层使用 H5、JS 做业务开发。这种开发模式，非常有利于办公协同APP的开放平台搭建，由 Native 端提供API，供第三方使用开发、快速迭代。</p>\n<h2 id=\"Hybrid-APP-框架\"><a href=\"#Hybrid-APP-框架\" class=\"headerlink\" title=\"Hybrid APP 框架\"></a>Hybrid APP 框架</h2><p>一个完整的 Hybrid APP 框架主要包括 Manager、WebView 、Bridge、Cache 等模块。整个框架设计理念是组合，而不是继承，因此框架设计的不是一个 XXWebView / XXWebViewController 基类，使用者不需要在业务代码中继承 WebView 。框架设计的是一个 Manager 对象，使用者只需要跟自己业务中的任意一种 WebView 进行绑定，就可以拥有 Hybrid 的能力。</p>\n<ul>\n<li><p>Manager 作为核心，负责处理 Hybrid 业务，校验和注册API</p>\n</li>\n<li><p>WebView 作为容器，负责展示前端页面，响应前端交互</p>\n</li>\n<li><p>Bridge 作为桥梁，负责 Native 和 JS 之间通信交互</p>\n</li>\n<li><p>Cache 作为缓存，负责缓存资源文件等</p>\n</li>\n</ul>\n<p>框架结构如下：</p>\n<p><img src=\"http://o8anxf7e1.bkt.clouddn.com/Hybrid%E6%A1%86%E6%9E%B6.png\" alt=\"Hybrid 框架\"></p>\n<h2 id=\"WebView-容器\"><a href=\"#WebView-容器\" class=\"headerlink\" title=\"WebView 容器\"></a>WebView 容器</h2><p>iOS8 以后苹果推出了一套新的 WKWebView，对于 UIWebView 和 WKWebView 的区别，可以参考 <a href=\"https://mp.weixin.qq.com/s?__biz=MzI1MTE2NTE1Ng==&amp;mid=2649516616&amp;idx=1&amp;sn=c16a7fc0ddaee2a6d5e1ad10373af9e3&amp;chksm=f1efeac3c69863d5942da9ba250c39e29af97a7c1ac22fce49d65dc3967c49c811b0f566b2c6#rd\" target=\"_blank\" rel=\"noopener\">教你使用 WKWebView 的正确姿势</a>，本框架暂时选用 WKWebView 作为容器，针对 WKWebView 的问题，本框架做了以下解决方案：</p>\n<h4 id=\"Cookie-问题\"><a href=\"#Cookie-问题\" class=\"headerlink\" title=\"Cookie 问题\"></a>Cookie 问题</h4><p>前端抛弃对 Cookie 的依赖，改为使用 H5 的 Storage 能力。另 Native 提供存读接口，以备前端使用存储功能。</p>\n<h4 id=\"NSURLProtocol-支持\"><a href=\"#NSURLProtocol-支持\" class=\"headerlink\" title=\"NSURLProtocol 支持\"></a>NSURLProtocol 支持</h4><p>WKWebView 包含一个 <code>browsingContextController</code> 属性对象，该对象提供了 <code>registerSchemeForCustomProtocol</code> 和 <code>unregisterSchemeForCustomProtocol</code> 两个方法，能通过注册 scheme 来代理同类请求，符合注册 scheme 类型的请求会走 NSURLProtocol 协议。但是这种方案存在两个严重缺陷：post 请求 body 数据被清空；对 ATS 支持不足。</p>\n<h4 id=\"跨域访问\"><a href=\"#跨域访问\" class=\"headerlink\" title=\"跨域访问\"></a>跨域访问</h4><p>iOS9 以后，可以通过 KVC 设置 <code>WKPreferences</code> 的 <code>allowFileAccessFromFileURLs</code> 和 <code>allowUniversalAccessFromFileURLs</code> 属性，来打开跨域访问。但是 iOS8 暂不支持。</p>\n<h4 id=\"Crash-白屏问题\"><a href=\"#Crash-白屏问题\" class=\"headerlink\" title=\"Crash 白屏问题\"></a>Crash 白屏问题</h4><p>在 WKWebView 白屏的时候，<code>webView.title</code> 会被置空，因此，可以在 <code>viewWillAppear</code> 的时候检测 <code>webView.title</code> 是否为空来 reload 页面。</p>\n<h4 id=\"缓存问题\"><a href=\"#缓存问题\" class=\"headerlink\" title=\"缓存问题\"></a>缓存问题</h4><p>针对单个资源文件，可以对该资源地址加时间戳避开缓存。针对全局资源文件，需要手动清理缓存，iOS9 以后，系统提供了缓存管理接口 <code>WKWebsiteDataStore</code>。而 iOS8，只能通过手动删除文件来解决了，WKWebView 的缓存数据会存储在 <code>~/Library/Caches/BundleID/WebKit/</code> 目录下，可通过删除该目录来实现清理缓存。</p>\n<h2 id=\"Bridge\"><a href=\"#Bridge\" class=\"headerlink\" title=\"Bridge\"></a>Bridge</h2><p>由于容器选择是 WKWebView，所以 JS 调用 Native 端有两种方式 <code>URL拦截</code> 和 <code>messageHandler</code> 。下图为两种方式性能对比</p>\n<p><img src=\"http://o8anxf7e1.bkt.clouddn.com/%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94.png\" alt=\"性能对比\"></p>\n<p><code>messageHandler</code> 对比 <code>URL拦截</code> 性能大约提升了 20%，受益于 WKWebView，本框架采用 <code>messageHandler</code> + <code>evaluatingJavaScript</code> 的方式进行通信交互。</p>\n<h4 id=\"JS-gt-Native\"><a href=\"#JS-gt-Native\" class=\"headerlink\" title=\"JS -&gt; Native\"></a>JS -&gt; Native</h4><h5 id=\"Native-注入对象\"><a href=\"#Native-注入对象\" class=\"headerlink\" title=\"Native 注入对象\"></a>Native 注入对象</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//配置对象注入</span><br><span class=\"line\">[self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;nativeObject&quot;];</span><br><span class=\"line\">//移除对象注入</span><br><span class=\"line\">[self.webView.configuration.userContentController removeScriptMessageHandlerForName:@&quot;nativeObject&quot;];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：如果当前 WebView 没用了，需要先移除这个对象注入，否则会造成内存泄漏，WebView 和所在 VC 循环引用，无法销毁。</p>\n</blockquote>\n<h5 id=\"JS-调用\"><a href=\"#JS-调用\" class=\"headerlink\" title=\"JS 调用\"></a>JS 调用</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//准备要传给native的数据，包括指令，数据，回调等</span><br><span class=\"line\">var data = &#123;</span><br><span class=\"line\">    action:&apos;xxxx&apos;,</span><br><span class=\"line\">    params:&apos;xxxx&apos;,</span><br><span class=\"line\">    callback:&apos;xxxx&apos;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//传递给客户端</span><br><span class=\"line\">window.webkit.messageHandlers.nativeObject.postMessage(data);</span><br></pre></td></tr></table></figure>\n<h5 id=\"Native-接收调用\"><a href=\"#Native-接收调用\" class=\"headerlink\" title=\"Native 接收调用\"></a>Native 接收调用</h5><p>当 JS 开始调用后，会调用到指定的 WKScriptMessageHandler 代理对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123;</span><br><span class=\"line\">    //1 取出 name 是否与注入 name 匹配</span><br><span class=\"line\">    if (message.name isEqualToString:@&quot;nativeObject&quot;) &#123;</span><br><span class=\"line\">        //2 取出对象，做后续操作</span><br><span class=\"line\">        NSDictionary *msgBody = message.body;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Native-gt-JS\"><a href=\"#Native-gt-JS\" class=\"headerlink\" title=\"Native -&gt; JS\"></a>Native -&gt; JS</h4><p>对于 WKWebView ，除了<code>evaluatingJavaScript</code>，还有 WKUserScript 这个方式可以执行 JS 代码，他们之间是有区别的</p>\n<ul>\n<li><p><code>evaluatingJavaScript</code> 是在客户端执行这条代码的时候立刻去执行当条JS代码</p>\n</li>\n<li><p>WKUserScript 是预先准备好JS代码，当 WKWebView 加载 Dom 的时候，执行当条 JS 代码</p>\n</li>\n</ul>\n<p>很明显这个虽然是一种通信方式，但并不能随时随地进行通信，并不适合选则作为设计 Bridge 的核心方案。</p>\n<h4 id=\"注入时机\"><a href=\"#注入时机\" class=\"headerlink\" title=\"注入时机\"></a>注入时机</h4><p>并不是所有前端页面都需要用到 Native 能力，因此在需要用到 Native 能力的页面，才注入 JS 代码，为其提供 Native 能力。与前端约定，如果需要，就假跳转至一个指定的 <code>URL</code>, 然后客户端在代理方法 <code>webView:(WKWebView *)webViewdecidePolicyForNavigationAction:decisionHandler:</code> 里判断 <code>URL</code> 是否为指定的 <code>URL</code>，如果是，则执行注入。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123;</span><br><span class=\"line\">    NSURL *url = navigationAction.request.URL;</span><br><span class=\"line\">    if ([url.absoluteString isEqualToString:@&quot;指定URL&quot;]) &#123;</span><br><span class=\"line\">        // 执行注入 JS 代码</span><br><span class=\"line\">        </span><br><span class=\"line\">        decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Bridge-框架\"><a href=\"#Bridge-框架\" class=\"headerlink\" title=\"Bridge 框架\"></a>Bridge 框架</h4><p>整个 Native 和 JS 的 Bridge 交互流程如下图所示：</p>\n<p><img src=\"http://o8anxf7e1.bkt.clouddn.com/bridge%E6%B5%81%E7%A8%8B.png\" alt=\"brdige流程\"></p>\n<p>在 Native / JS 端，创建 Bridge 对象，该对象需包含：</p>\n<h5 id=\"property\"><a href=\"#property\" class=\"headerlink\" title=\"property\"></a>property</h5><ul>\n<li>messageHandlers 字典，以 handlerName 作为 key，保存对应 function</li>\n<li>responseCallbacks 字典，以 callbackId 作为 key，保存响应 function</li>\n</ul>\n<h5 id=\"function\"><a href=\"#function\" class=\"headerlink\" title=\"function\"></a>function</h5><ul>\n<li>doSend: 调用另一端方法，传递 message 字典参数</li>\n<li>responseAnotherMethod: 响应另一端的调用，接收 message 字典参数</li>\n</ul>\n<h2 id=\"Manager\"><a href=\"#Manager\" class=\"headerlink\" title=\"Manager\"></a>Manager</h2><p>Manager 为整个 Hybrid 核心，负责 JS 方法到 Native 端的映射，可灵活扩展。利用 runtime 特性，使用得到的 className 和 functionName 反射出指定的对象，并执行指定函数。</p>\n<h4 id=\"权限验证\"><a href=\"#权限验证\" class=\"headerlink\" title=\"权限验证\"></a>权限验证</h4><p>针对打开的 WebView, 是否拥有合法使用 Hybrid 的权限需要进行验证，只有验证通过的页面，才能使用原生提供的能力。Manager 提供入口，具体验证由上层实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)authenticationSignatureParameter:(NSDictionary *)parameter comlete:(void (^)(NSError *error))complete;</span><br></pre></td></tr></table></figure>\n<h4 id=\"组件协议\"><a href=\"#组件协议\" class=\"headerlink\" title=\"组件协议\"></a>组件协议</h4><p>JS 页面加载完，在使用 Native 能力之前，需要进行注册，即告知 Native 当前页面所需要使用的 API 列表。Manager 处理该流程，验证 Native 是否实现该 API，同时把 API 转换成对象，对象遵循以下协议：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@protocol KKWebViewJSApiBaseProtocol &lt;NSObject&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@required</span><br><span class=\"line\">/// api名字</span><br><span class=\"line\">@property (nonatomic, copy) NSString *apiName;</span><br><span class=\"line\">/// 是否支持js多次回调</span><br><span class=\"line\">@property (nonatomic, assign) NSInteger isNeedRegistId;</span><br><span class=\"line\">/// 是否为事件类型，客户端调用，类似发通知给JS</span><br><span class=\"line\">@property (nonatomic, assign) NSInteger isEvent;</span><br><span class=\"line\">/// api接口参数数据</span><br><span class=\"line\">@property (nonatomic, strong) NSDictionary *paramData;</span><br><span class=\"line\">/// api接口响应回调</span><br><span class=\"line\">@property (nonatomic, copy) WVJBResponseCallback responseCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, weak) KKWebViewJavaScriptManager *jsManager;</span><br><span class=\"line\"></span><br><span class=\"line\">@end;</span><br></pre></td></tr></table></figure>\n<h4 id=\"反射函数\"><a href=\"#反射函数\" class=\"headerlink\" title=\"反射函数\"></a>反射函数</h4><p>Manager 把 API 转换成对象时，利用 Objective-C 的 runtime 反射机制：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class cls = NSClassFromString(className);</span><br><span class=\"line\">if ([cls conformsToProtocol:@protocol(KKWebViewJSApiBaseProtocol)]) &#123;</span><br><span class=\"line\">    id&lt;KKWebViewJSApiBaseProtocol&gt; obj = [[cls alloc] init];</span><br><span class=\"line\">    if ([obj respondsToSelector:NSSelectorFromString(functionName)]) &#123;</span><br><span class=\"line\">#pragma clang diagnostic push</span><br><span class=\"line\">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class=\"line\">        [obj performSelector:NSSelectorFromString(functionName)];</span><br><span class=\"line\">#pragma clang diagnostic pop</span><br><span class=\"line\">        return obj;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        NSLog(@&quot;function is not found&quot;);</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    NSLog(@&quot;clss is not found&quot;);</span><br><span class=\"line\">     return nil;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><a href=\"https://github.com/cozelight/JSSDK\" target=\"_blank\" rel=\"noopener\">Demo链接</a></p>\n</blockquote>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzI1MTE2NTE1Ng==&amp;mid=2649516616&amp;idx=1&amp;sn=c16a7fc0ddaee2a6d5e1ad10373af9e3&amp;chksm=f1efeac3c69863d5942da9ba250c39e29af97a7c1ac22fce49d65dc3967c49c811b0f566b2c6#rd\" target=\"_blank\" rel=\"noopener\">教你使用 WKWebView 的正确姿势</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA\" target=\"_blank\" rel=\"noopener\">WKWebView 那些坑</a></p>\n<p><a href=\"http://www.cnblogs.com/yexiaochai/p/4921635.html\" target=\"_blank\" rel=\"noopener\">浅谈Hybrid技术的设计与实现</a></p>\n<p><a href=\"https://lvwenhan.com/ios/460.html\" target=\"_blank\" rel=\"noopener\">自己动手打造基于 WKWebView 的混合开发框架</a></p>\n<p><a href=\"http://blog.csdn.net/byeweiyang/article/details/75102051\" target=\"_blank\" rel=\"noopener\">58 同城 iOS 客户端 Hybrid 框架探索</a></p>\n<p><a href=\"http://awhisper.github.io/2018/01/02/hybrid-jscomunication/\" target=\"_blank\" rel=\"noopener\">从零收拾一个hybrid框架</a></p>\n","categories":[],"tags":[]}]